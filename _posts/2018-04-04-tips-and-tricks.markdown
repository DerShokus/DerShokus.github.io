---
layout: post
title: "Tips and tricks"
date: 2018-04-04
categories: cpp t'n't
---
### TLTR:
Не знаю о чем писать конкретно и потому буду писать в этом посте просто заметки о коде на C++.

### 1. Интрузивность
Интрузивность - плохо само по себе т.е. если нет особых условий - выбираем неинтрузивный подход.

К примеру у нас есть метод сериализации (в файл, базу данных, еще куда-то):
```cpp
// Интрузивно (функциональность встроена в object)
class Serializer {
    template <class T>
    void write(const T& object) {
        ss << object;
        // or
        object.write(buffer, sizeof(buffer));
    }
    serializer_stream ss;
    uint8_t buffer[...];
};

// Неинтрузивно (функциональность снаружи)
class Serializer {
    template <class T>
    void write(const T& object) {
        serializer_traits<decltype(object)>::serialize(ss);
        // or 
        serializer_traits<decltype(object)>::serialize(buffer);
};
```

Интрузивный подход проще, но в код класса встраивается совершенно посторонняя логика, что - минус.
С неинтрузивным подходом сложнее и есть грабли. Был какой-то db-framework который использовал
подход как в коде выше `serializer_traits`, но когда один и тот же объект нужно сериализовать
разными способами в зависимости от таблицы (или еще чего...) начинались проблемы.

В общем случае можно расширять условия: `serializer_traits<decltype(object), condition1, condition2, ...>::serialize(...)`
но это выглядит страшно. Иногда возможно сделать проще, передавая тип `traits` в класс/метод
сериализации. Таким образом мы можем управлять как будет использоваться наш тип `T`, но не 
стоит доходить до фанатизма (в бусте есть интрузивные контейнеры, которые весьма полезны в быту).
